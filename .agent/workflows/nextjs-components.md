---
description:
---

ユーザーからの要望に基づき、ソースの内容をNext.js 15開発におけるReact Server Components (RSC) の使用ガイドラインとして抽出し、GitHub Copilot (VSCode) に読み込ませるための指示書を作成します。この指示書は、RSCの理想と現実のギャップを踏まえ、本番環境での安定性と開発者体験（DX）を重視した実践的な指針を提供します。

---

## Next.js 15 開発指示書：React Server Components (RSC) 利用ガイドライン

### 1. 全体戦略：ハイブリッドレンダリングの採用

本プロジェクトでは、RSCのパフォーマンス上の利点と、Client Components (CC) のデバッグ・インタラクティビティの容易さの**両方を活用するハイブリッドアプローチ**を基本戦略とします。

RSCは「銀の弾丸（決め手）」ではないことを認識し、ユースケースを厳選すること（選択的導入）が求められます。

| コンポーネントの種類 | 役割と利用推奨ケース | 根拠 |
| :--- | :--- | :--- |
| **Server Components (SC)** | **静的コンテンツ、SEO、データフェッチ、レイアウト**に集中させます。 | 静的コンテンツサイト、ブログ記事、ダッシュボードのレイアウト、表示専用のデータテーブルなど、インタラクティビティが不要な部分。 |
| **Client Components (CC)** | **インタラクティビティ、状態管理、リアルタイム機能、複雑なフォーム**に集中させます。 | リアルタイム更新（WebSocket）、複雑なフォーム（バリデーション）、高度にインタラクティブなUI（フィルタリング、ソート、ページネーション）など。 |

### 2. RSC使用時の必須テクニカルディレクティブ

#### 2.1. データフェッチの並列化（ウォーターフォールの回避）

RSCはコンポーネントをシーケンシャルにレンダリングするため、ネストされた非同期コンポーネントは**暗黙のウォーターフォール**（逐次的な待ち時間）を引き起こし、パフォーマンスを悪化させます。

*   **指示：** 兄弟コンポーネント間で複数のデータフェッチが必要な場合は、必ずルートのServer Component内で **`Promise.all()`** を使用してデータフェッチを**手動で並列化**します。
*   **トレードオフ：** この修正により、Server Componentsが提供するカプセル化や関心の分離の利点は失われますが、本番環境での遅延（例：合計時間が750msとなるケース）を回避するために必須です。

```typescript
// ✅ Good: Parallel (ウォーターフォール回避)
const [data1, data2, data3] = await Promise.all([
  getData1(),
  getData2(),
  getData3(),
]);
// ... data1, data2, data3 を Props として子コンポーネントに渡す
```

#### 2.2. キャッシュ制御と再検証

Next.js 14以降の積極的なキャッシュ機構は、データベースクエリ結果をサーバー上でキャッシュし、データが無効化（invalidate）されない限り、ユーザーに**古い情報が表示される**という本番環境でのバグ（例：新しい投稿が表示されない）を引き起こす可能性があります。

*   **指示：** リアルタイムまたは即時性が求められるデータ表示ページでは、不必要なキャッシュを防ぐため、ページファイルに **`export const revalidate = 0`** を設定することを検討します。
*   **注意点：** これによりパフォーマンス上の利点（ページロードごとのDBアクセス）は失われますが、データの鮮度を保つことが優先されます。

#### 2.3. クライアント/サーバー境界の管理

Client Component (CC) は、その定義（`'use client'`）より下で Server Component (SC) を直接インポートすることはできません。

*   **指示：** SC内でCCをラップし、**SCを子要素 (`children`) またはプロパティとしてCCに渡す**パターンを厳守します。これは直感的でないため、特に経験の浅い開発者が苦戦しないよう、このパターンを徹底します。

```typescript
// Parent (Server Component)
<ClientComponent>
  <ServerComponent /> {/* ✅ SCをchildrenとして渡す */}
</ClientComponent>
```

#### 2.4. フォームとServer Actionsの利用制限

Server Actionsはエラーハンドリングやローディング状態（スピナー）の表示を複雑化させます。特に、ローディング状態には **`useFormStatus`** という新しいフックと、ボタン用のClient Componentが必要となり、ファイル構成が複雑になります。

*   **指示：** Server Actionsは、**非常にシンプルで、クライアントサイドのバリデーションや複雑なローディング処理が不要なフォーム**に限定して使用します。
*   **複雑なフォームへの対応：** 複数ステップのフォームや、きめ細かなフィールドレベルのエラーハンドリングが必要な場合は、従来のAPIルートとClient Component (`'use client'`)、および従来のデータフェッチライブラリ（例：Tanstack Queryなど）を再検討します。

#### 2.5. TypeScriptの型安全性確保

RSCは、サーバーコンポーネントからクライアントコンポーネントへpropsを渡す際、内部的にデータをJSONにシリアライズします。このとき、Prismaの `Date` オブジェクトなどは**文字列に変換され**、TypeScriptはこれを型エラーとして検出できず、**本番環境でランタイムエラー**を引き起こします。

*   **指示：** データベース呼び出し層において、クライアントに渡される可能性のある `Date` オブジェクトなどの非JSONシリアライズ可能オブジェクトは、必ず手動で **`toISOString()`** などを使って文字列に変換し、安全性を確保します。
*   **注意点：** サーバー側とクライアント側で、データ型定義を分離または調整する必要があることを開発者に周知します。

### 3. 開発者体験（DX）とデバッグへの対応

Server Components環境でのデバッグは、Client Componentsと比較して**所要時間が大幅に増加する**傾向があります（10〜30分から1〜3時間へ）。

*   **指示 1：デバッグアプローチの変更**
    *   ブラウザーのDevToolsが使用できないため、エラーは**ターミナル側で確認**することを徹底します。
    *   デバッグには `console.log` を多用する必要があることを前提とします。
*   **指示 2：エラー境界 (Error Boundaries) の設置**
    *   Server Componentsが本番環境で失敗した場合に備え、適切なエラー境界 (`app/error.tsx` など) を設定します。
    *   **エラー境界は必ずClient Component (`'use client'`) でなければならない**ことに留意します。

### 4. 採用意思決定フレームワーク（参考）

Next.js 15でApp Routerの採用を検討する際は、以下のフレームワークに基づき、RSCの導入レベルを決定します。

| 質問 | 意思決定の指針 |
| :--- | :--- |
| **アプリのインタラクティビティの割合** | 70%超がインタラクティブな場合は、CCを堅持します。30%未満であればRSCを広く導入できます。 |
| **チームの経験レベル** | 経験の浅い開発者が多い場合、学習曲線が急峻（オンボーディング期間が2週間から6週間に増加した事例あり）なため、RSCの採用は慎重に進めるか、見送りを検討します。 |
| **タイムライン** | 厳しいデッドラインがあるプロジェクトでは、デバッグの難しさからRSCの採用を避ける方が賢明です。 |

---
**この指示書の目的は、RSCの理想的な機能（パフォーマンス向上、バンドルサイズ削減） を追求しつつ、本番運用で直面した具体的な課題（ウォーターフォール、キャッシュ、デバッグの困難さ） を回避するための実践的なガードレールを提供することです。**

---
（この指示書は、RSCを扱う際、コンポーネントがまるで**二重国籍**を持つかのように振る舞うため、どちらの国（サーバーかクライアントか）のルールが適用されるかを常に意識し、特に国境（コンポーネント間のプロパティ受け渡し）でデータのシリアライズとフローを厳密に管理する必要がある、という状況を反映しています。）
