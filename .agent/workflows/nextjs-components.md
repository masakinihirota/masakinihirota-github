---
description:
---

ユーザーからの要望に基づき、ソースの内容をNext.js 15開発におけるReact Server Components (RSC) の使用ガイドラインとして抽出し、GitHub Copilot (VSCode) に読み込ませるための指示書を作成します。この指示書は、RSCの理想と現実のギャップを踏まえ、本番環境での安定性と開発者体験（DX）を重視した実践的な指針を提供します。

---

## Next.js 15 開発指示書：React Server Components (RSC) 利用ガイドライン

### 1. 全体戦略：ハイブリッドレンダリングの採用

本プロジェクトでは、RSCのパフォーマンス上の利点と、Client Components (CC) のデバッグ・インタラクティビティの容易さの**両方を活用するハイブリッドアプローチ**を基本戦略とします。

RSCは「銀の弾丸（決め手）」ではないことを認識し、ユースケースを厳選すること（選択的導入）が求められます。

| コンポーネントの種類 | 役割と利用推奨ケース | 根拠 |
| :--- | :--- | :--- |
| **Server Components (SC)** | **静的コンテンツ、SEO、データフェッチ、レイアウト**に集中させます。 | 静的コンテンツサイト、ブログ記事、ダッシュボードのレイアウト、表示専用のデータテーブルなど、インタラクティビティが不要な部分。 |
| **Client Components (CC)** | **インタラクティビティ、状態管理、リアルタイム機能、複雑なフォーム**に集中させます。 | リアルタイム更新（WebSocket）、複雑なフォーム（バリデーション）、高度にインタラクティブなUI（フィルタリング、ソート、ページネーション）など。 |

### 2. RSC使用時の必須テクニカルディレクティブ

#### 2.1. データフェッチの並列化（ウォーターフォールの回避）

RSCはコンポーネントをシーケンシャルにレンダリングするため、ネストされた非同期コンポーネントは**暗黙のウォーターフォール**（逐次的な待ち時間）を引き起こし、パフォーマンスを悪化させます。

*   **指示：** 兄弟コンポーネント間で複数のデータフェッチが必要な場合は、必ずルートのServer Component内で **`Promise.all()`** を使用してデータフェッチを**手動で並列化**します。
*   **トレードオフ：** この修正により、Server Componentsが提供するカプセル化や関心の分離の利点は失われますが、本番環境での遅延（例：合計時間が750msとなるケース）を回避するために必須です。

```typescript
// ✅ Good: Parallel (ウォーターフォール回避)
const [data1, data2, data3] = await Promise.all([
  getData1(),
  getData2(),
  getData3(),
]);
// ... data1, data2, data3 を Props として子コンポーネントに渡す
```

#### 2.2. キャッシュ制御と再検証

Next.js 14以降の積極的なキャッシュ機構は、データベースクエリ結果をサーバー上でキャッシュし、データが無効化（invalidate）されない限り、ユーザーに**古い情報が表示される**という本番環境でのバグ（例：新しい投稿が表示されない）を引き起こす可能性があります。

*   **指示：** リアルタイムまたは即時性が求められるデータ表示ページでは、不必要なキャッシュを防ぐため、ページファイルに **`export const revalidate = 0`** を設定することを検討します。
*   **注意点：** これによりパフォーマンス上の利点（ページロードごとのDBアクセス）は失われますが、データの鮮度を保つことが優先されます。

#### 2.3. クライアント/サーバー境界の管理

Client Component (CC) は、その定義（`'use client'`）より下で Server Component (SC) を直接インポートすることはできません。

*   **指示：** SC内でCCをラップし、**SCを子要素 (`children`) またはプロパティとしてCCに渡す**パターンを厳守します。これは直感的でないため、特に経験の浅い開発者が苦戦しないよう、このパターンを徹底します。

```typescript
// Parent (Server Component)
<ClientComponent>
  <ServerComponent /> {/* ✅ SCをchildrenとして渡す */}
</ClientComponent>
```

#### 2.4. フォームとServer Actionsの利用制限

Server Actionsはエラーハンドリングやローディング状態（スピナー）の表示を複雑化させます。特に、ローディング状態には **`useFormStatus`** という新しいフックと、ボタン用のClient Componentが必要となり、ファイル構成が複雑になります。

*   **指示：** Server Actionsは、**非常にシンプルで、クライアントサイドのバリデーションや複雑なローディング処理が不要なフォーム**に限定して使用します。
*   **指示：** Server Actionsは、**非常にシンプルで、クライアントサイドのバリデーションや複雑なローディング処理が不要なフォーム**に限定して使用します。
*   **複雑なフォームへの対応：** 複数ステップのフォーム、動的なフィールド追加、またはきめ細かなフィールドレベルのエラーハンドリングが必要な場合は、**無理にServer Actionsを使わず**、従来のAPIルートとClient Component (`'use client'`)、およびReact Hook Formなどのライブラリを組み合わせる構成を推奨します。無理なServer Actions化は「隠れたコスト（開発体験の悪化）」につながります。

#### 2.5. TypeScriptの型安全性確保

RSCは、サーバーコンポーネントからクライアントコンポーネントへpropsを渡す際、内部的にデータをJSONにシリアライズします。このとき、Prismaの `Date` オブジェクトなどは**文字列に変換され**、TypeScriptはこれを型エラーとして検出できず、**本番環境でランタイムエラー**を引き起こします。

*   **指示：** データベース呼び出し層において、クライアントに渡される可能性のある `Date` オブジェクトなどの非JSONシリアライズ可能オブジェクトは、必ず手動で **`toISOString()`** などを使って文字列に変換し、安全性を確保します。
*   **注意点：** サーバー側とクライアント側で、データ型定義を分離または調整する必要があることを開発者に周知します。

#### 2.6. Context Providersの利用

Context APIはClient Componentsでのみ動作します。

*   **指示：** アプリケーション全体でContext（テーマ、認証など）を使用する場合は、`src/providers.tsx` のような専用のClient Componentを作成し、そこでContext Providerをレンダリングします。
*   **実装パターン：** Root Layout (`app/layout.tsx`) でこのProviderコンポーネントをインポートし、アプリ全体をラップします。

```typescript
// src/providers.tsx
'use client'

import { ThemeProvider } from 'next-themes'

export function Providers({ children }: { children: React.ReactNode }) {
  return <ThemeProvider>{children}</ThemeProvider>
}
```

#### 2.7. Server-Onlyコードの保護

サーバー専用のコード（APIキーの使用、DB直接接続など）が誤ってクライアントバンドルに含まれることを防ぐ必要があります。

*   **指示：** `server-only` パッケージをインストールし、サーバー専用のユーティリティファイル（`src/lib/db.ts` など）の先頭に `import 'server-only'` を記述します。これにより、誤ってClient Componentからインポートされた場合にビルドエラーが発生し、事故を防げます。

#### 2.8. サードパーティコンポーネントの利用

多くのnpmパッケージ（UIライブラリなど）はまだ `'use client'` ディレクティブを含んでいない場合がありますが、内部でブラウザAPI（`useState`, `window`など）を使用しています。

*   **指示：** これらをServer Componentで直接インポートしてエラーになる場合は、**薄いラッパーClient Component**を作成して再エクスポートします。

```typescript
// src/components/client-wrapper.tsx
'use client'
export { Carousel } from 'some-ui-library'
```

#### 2.9. 環境変数の取り扱い

*   **指示：** サーバーサイドでのみ使用すべき機密情報（DBパスワード、API Secret）には `NEXT_PUBLIC_` プレフィックスを**絶対につけない**でください。
*   **検証：** ビルド時やPRレビュー時に、`process.env` の参照箇所をチェックし、クライアントコードに機密情報が漏れていないか確認します。

### 3. 開発者体験（DX）とデバッグへの対応

Server Components環境でのデバッグは、Client Componentsと比較して**所要時間が大幅に増加する**傾向があります（10〜30分から1〜3時間へ）。

*   **指示 1：デバッグアプローチの変更**
    *   ブラウザーのDevToolsが使用できないため、エラーは**ターミナル側で確認**することを徹底します。
    *   デバッグには `console.log` を多用する必要があることを前提とします。
*   **指示 2：エラー境界 (Error Boundaries) の設置**
    *   Server Componentsが本番環境で失敗した場合に備え、適切なエラー境界 (`app/error.tsx` など) を設定します。
    *   **エラー境界は必ずClient Component (`'use client'`) でなければならない**ことに留意します。

### 4. 採用意思決定フレームワーク（参考）

Next.js 15でApp Routerの採用を検討する際は、以下のフレームワークに基づき、RSCの導入レベルを決定します。

| 質問 | 意思決定の指針 |
| :--- | :--- |
| **アプリのインタラクティビティの割合** | 70%超がインタラクティブな場合は、CCを堅持します。30%未満であればRSCを広く導入できます。 |
| **チームの経験レベル** | 経験の浅い開発者が多い場合、学習曲線が急峻（オンボーディング期間が2週間から6週間に増加した事例あり）なため、RSCの採用は慎重に進めるか、見送りを検討します。 |
| **タイムライン** | 厳しいデッドラインがあるプロジェクトでは、デバッグの難しさからRSCの採用を避ける方が賢明です。 |

### 5. 実装チェックリスト

開発完了時、以下の項目を確認してください。

- [ ] **ウォーターフォール回避:** 複数のデータフェッチがある場合、`Promise.all` で並列化されているか？
- [ ] **キャッシュ確認:** リアルタイム性が重要なページで `revalidate = 0` または適切なキャッシュタグが設定されているか？
- [ ] **境界管理:** Server ComponentからClient Componentへのprops渡しで、Date型などが文字列化されているか？
- [ ] **機密情報保護:** `server-only` が適切に使用され、`NEXT_PUBLIC_` が乱用されていないか？
- [ ] **Context分離:** ProviderはClient Componentとして切り出されているか？

---
**この指示書の目的は、RSCの理想的な機能（パフォーマンス向上、バンドルサイズ削減） を追求しつつ、本番運用で直面した具体的な課題（ウォーターフォール、キャッシュ、デバッグの困難さ） を回避するための実践的なガードレールを提供することです。**

---
（この指示書は、RSCを扱う際、コンポーネントがまるで**二重国籍**を持つかのように振る舞うため、どちらの国（サーバーかクライアントか）のルールが適用されるかを常に意識し、特に国境（コンポーネント間のプロパティ受け渡し）でデータのシリアライズとフローを厳密に管理する必要がある、という状況を反映しています。）
